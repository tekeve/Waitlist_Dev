{% extends "base.html" %}
{% load humanize %}

<!-- This sets the page title -->
{% block title %}EVE Waitlist - View{% endblock %}


<!-- These styles are specific to the waitlist view -->
{% block styles %}
<style>
    .waitlist-container {
        display: flex;
        flex-direction: row;
        gap: 10px;
        padding: 10px;
        /* Allow horizontal scrolling on small screens */
        overflow-x: auto;
        /* Set a height so vertical scrollbars appear inside columns */
        height: calc(100vh - var(--header-height) - 20px); /* Full height minus header */
    }

    .waitlist-column {
        flex: 1 0 280px; /* MODIFIED: Was 300px */
        min-width: 280px; /* MODIFIED: Was 300px */
        max-width: 320px; /* MODIFIED: Was 340px */
        display: flex;
        flex-direction: column;
        background: none; /* MODIFIED: Removed column background */
        border-radius: 8px;
        /* Handle vertical overflow */
        height: 100%;
    }

    .column-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        border-bottom: 2px solid #444;
    }

        .column-header h2 {
            margin: 0;
            font-size: 1.2em;
            color: #fff;
        }

    .column-count {
        font-size: 1.2em;
        font-weight: bold;
        background: #444;
        color: #fff;
        padding: 2px 8px;
        border-radius: 5px;
    }

    /* Column Header Colors */
    .status-PENDING {
        border-top: 3px solid #ffc107;
    }

    .status-APPROVED {
        border-top: 3px solid #28a745;
    }

    /* --- NEW: In Fleet Status --- */
    .status-IN_FLEET {
        border-top: 3px solid #3b5998;
    }

    .fit-card-list {
        list-style: none;
        padding: 5px; /* MODIFIED: Was 8px */
        margin: 0;
        /* Make the list scrollable, not the whole column */
        overflow-y: auto;
        height: 100%;
    }

        /* Scrollbar styling */
        .fit-card-list::-webkit-scrollbar {
            width: 8px;
        }

        .fit-card-list::-webkit-scrollbar-track {
            background: rgba(42, 42, 42, 0.5); /* MODIFIED: Made track semi-transparent */
            border-radius: 4px;
        }

        .fit-card-list::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

            .fit-card-list::-webkit-scrollbar-thumb:hover {
                background: #666;
            }


    .fit-card {
        background: #333; /* MODIFIED: Re-added background */
        border: 1px solid #444; /* MODIFIED: Re-added border */
        border-radius: 5px;
        margin-bottom: 5px; /* MODIFIED: Was 8px */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* MODIFIED: Re-added shadow */
        /* --- NEW: Transition for invite --- */
        transition: opacity 0.5s ease;
    }

        .fit-card.status-IN_FLEET {
            opacity: 0.4; /* Fade out invited pilots */
        }

    .card-header {
        display: flex;
        align-items: center;
        gap: 8px; /* MODIFIED: Was 10px */
        padding: 6px; /* MODIFIED: Was 8px */
        border-bottom: 1px solid #444;
    }

    .pilot-portrait {
        width: 40px; /* MODIFIED: Was 48px */
        height: 40px; /* MODIFIED: Was 48px */
        border-radius: 5px;
        border: 1px solid #555;
    }

    .pilot-name {
        font-weight: 600;
        font-size: 1.1em;
        color: #fff;
        /* Prevent long names from breaking layout */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* --- NEW: Wait Timer Style --- */
    .wait-timer {
        font-size: 0.8em;
        font-weight: bold;
        color: #ffc107; /* Yellow */
        margin-left: auto;
        padding: 2px 6px;
        background: rgba(0,0,0,0.2);
        border-radius: 4px;
    }

    /* --- NEW: In Fleet Timer Style --- */
    .fit-card.status-IN_FLEET .wait-timer {
        color: #63d471; /* Green */
    }

    .card-body {
        padding: 6px; /* MODIFIED: Was 8px */
        font-size: 0.9em;
    }

    /* --- NEW: Layout for fit info + ship image --- */
    .card-body-row {
        display: flex;
        justify-content: space-between;
        gap: 10px;
    }

    .card-fit-details {
        display: flex;
        flex-direction: column;
        flex-grow: 1; /* Take up available space */
        min-width: 0; /* Allow shrinking */
    }

    .ship-image-container {
        flex-shrink: 0; /* Don't shrink */
        /* --- NEW: Add cursor for clickable --- */
        cursor: pointer;
        border-radius: 5px;
        padding: 4px;
        transition: background-color 0.2s;
    }

        .ship-image-container:hover {
            background-color: #444;
        }

        .ship-image-container img {
            width: 56px; /* MODIFIED: Was 64px */
            height: 56px; /* MODIFIED: Was 64px */
            display: block; /* Remove bottom space */
        }
    /* --- END NEW --- */


    .fit-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
        /* --- MODIFIED: Justify left --- */
        justify-content: flex-start;
        gap: 5px;
    }

        .fit-info strong {
            color: #aaa;
            flex-shrink: 0;
        }

        .fit-info .placeholder {
            color: #ddd;
            font-weight: 500;
            /* --- Allow text to wrap --- */
            white-space: normal;
            overflow: hidden;
            text-overflow: ellipsis;
            /* --- Justify left --- */
            text-align: left;
        }

    .fit-issues {
        margin-top: 8px;
        font-size: 0.85em;
    }

        .fit-issues strong {
            color: #ffc107;
        }
        /* Yellow */
        .fit-issues .placeholder {
            color: #ffc107;
        }

    .pilot-stats {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #444;
        display: flex;
        justify-content: space-around;
        font-size: 0.8em;
    }

    .stat-item {
        text-align: center;
    }

        .stat-item strong {
            color: #aaa;
        }

        .stat-item .placeholder {
            color: #ddd;
            font-weight: 600;
        }

    /* --- NEW: FC Action Bar --- */
    .fc-actions {
        display: flex;
        gap: 5px;
        border-top: 1px solid #444;
        padding: 6px 8px 4px 8px; /* MODIFIED: Was 8px 10px 5px 10px */
        margin-top: 8px; /* MODIFIED: Was 10px */
        /* --- MODIFIED: Align buttons to the right --- */
        justify-content: flex-end;
    }

    .fc-btn {
        background: #555;
        border: none;
        border-radius: 5px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        padding: 5px 8px;
        /* --- MODIFIED: Slightly larger emoji --- */
        font-size: 1.1em;
        line-height: 1;
        transition: background-color 0.2s, transform 0.1s;
    }

        .fc-btn:hover {
            transform: scale(1.1);
        }

        .fc-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

    .btn-approve {
        background-color: #28a745;
    }

        .btn-approve:hover {
            background-color: #34c254;
        }

    .btn-deny {
        background-color: #dc3545;
    }

        .btn-deny:hover {
            background-color: #e64a58;
        }

    /* --- NEW: Invite Button --- */
    .btn-invite {
        background-color: #3b5998;
        font-size: 0.9em; /* Make text fit */
        padding: 6px 8px; /* Adjust padding */
    }

        .btn-invite:hover {
            background-color: #4e71bb;
        }


    .waitlist-closed-msg {
        color: #aaa;
        font-style: italic;
        padding: 20px;
        text-align: center;
    }
</style>
{% endblock %}


{% block content %}
<!--
This container will be the target for our live polling.
It will be filled by the partial template on page load.
-->
<div class="waitlist-container" id="waitlist-container-live">
    {% include "_waitlist_columns.html" %}
</div>
{% endblock %}


<!-- --- NEW JAVASCRIPT BLOCK --- -->
{% block scripts %}
<script>
    // This script block will handle both FC actions and the new timer/polling

    // --- CSRF Token for all API requests ---
    const csrfToken = "{{ csrf_token }}";

    // --- Check if user is an FC ---
    const isFC = {{ is_fc|yesno:"true,false" }};

    // --- 1. FC ACTION HANDLER (Approve/Deny) ---

    function handleFCAction(event) {
        // Find the button that was clicked
        const button = event.target.closest('.fc-btn');
        if (!button) return; // Click wasn't on a button

        // --- MODIFICATION: Ignore invite buttons ---
        if (button.classList.contains('btn-invite')) {
            return;
        }
        // --- END MODIFICATION ---

        const fitId = button.dataset.fitId;
        const action = button.dataset.action;
        const card = document.getElementById(`fit-card-${fitId}`);

        // Disable all buttons on this card to prevent double-clicks
        if (card) {
            card.querySelectorAll('.fc-btn').forEach(btn => btn.disabled = true);
        }

        const formData = new FormData();
        formData.append('fit_id', fitId);
        formData.append('action', action);

        fetch("{% url 'waitlist:api_update_fit_status' %}", {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // --- FIX: Only remove on 'deny' ---
                // Let the poller handle moving 'approved' fits
                if (action === 'deny') {
                    if (card) {
                        card.remove();
                    }
                } else {
                    // Optional: show a temporary "approved" state
                    // For now, we just leave buttons disabled
                }
            } else {
                // Re-enable buttons on failure
                if (card) {
                    card.querySelectorAll('.fc-btn').forEach(btn => btn.disabled = false);
                }
                alert(`Error: ${data.message}`);
            }
        })
        .catch(error => {
            // Re-enable buttons on failure
            if (card) {
                card.querySelectorAll('.fc-btn').forEach(btn => btn.disabled = false);
            }
            alert(`Network Error: ${error.message}`);
        });
    }

    // ---
    // --- NEW: FC INVITE HANDLER
    // ---
    function handleFCInvite(event) {
        const button = event.target.closest('.btn-invite');
        if (!button) return; // Not an invite button

        const fitId = button.dataset.fitId;
        const card = document.getElementById(`fit-card-${fitId}`);

        button.disabled = true;
        button.textContent = '...'; // Show loading

        const formData = new FormData();
        formData.append('fit_id', fitId);

        fetch("{% url 'waitlist:api_fc_invite_pilot' %}", {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Success! Let the poller handle the removal.
                // We'll just fade out the card.
                if (card) {
                    card.classList.add('status-IN_FLEET');
                }
            } else {
                // Show a pop-up on error
                // We can use our new custom confirm modal as an alert
                showCustomConfirm(
                    `<strong>Invite Failed</strong><br>${data.message}`,
                    () => {} // Pass an empty function
                );
                button.disabled = false;
                button.textContent = 'Invite';
            }
        })
        .catch(err => {
            showCustomConfirm(
                `<strong>Network Error</strong><br>${err.message}`,
                () => {}
            );
            button.disabled = false;
            button.textContent = 'Invite';
        });
    }
    // ---
    // --- END NEW INVITE HANDLER
    // ---

    // --- 2. TIMER AND LIVE POLLING ---

    const waitlistContainer = document.getElementById('waitlist-container-live');
    let pollingInterval = null;
    let timerInterval = null;

    // This function updates all timers on the page
    function updateWaitTimers() {
        const fitCards = waitlistContainer.querySelectorAll('.fit-card');
        const now = new Date();

        fitCards.forEach(card => {
            const timerEl = card.querySelector('.wait-timer');
            const submittedTime = new Date(card.dataset.submittedTime);

            const diffMs = now - submittedTime;
            const diffMins = Math.floor(diffMs / 60000); // Total minutes

            if (timerEl) {
                timerEl.textContent = `${diffMins}m`;
            }
        });
    }

    // This function fetches the new HTML
    function fetchWaitlistHTML() {
        fetch("{% url 'waitlist:api_get_waitlist_html' %}")
            .then(response => {
                if (response.ok) {
                    return response.text();
                }
                throw new Error('Waitlist closed or error');
            })
            .then(html => {
                // --- This is the key: replace the content ---
                waitlistContainer.innerHTML = html;

                // After redrawing, re-update the timers immediately
                updateWaitTimers();
            })
            .catch(error => {
                // Waitlist is probably closed
                waitlistContainer.innerHTML = `<p class="waitlist-closed-msg">Waitlist is currently closed. The page will refresh when it opens.</p>`;
            });
    }

    // --- 3. NEW: FIT DETAIL MODAL HANDLER ---

    // Get modal elements (they are in base.html)
    const fitModalOverlay = document.getElementById('fit-detail-modal-overlay');
    const fitModalCloseBtn = document.getElementById('fit-detail-modal-close-btn');
    const fitModalCancelBtn = document.getElementById('fit-detail-modal-cancel-btn');
    const fitModalBody = document.getElementById('fit-detail-modal-body');
    const fitModalTitle = document.getElementById('fit-detail-modal-title');

    // --- NEW: Get modal footer buttons ---
    const fitModalAcceptBtn = document.getElementById('fit-detail-modal-accept-btn');
    const fitModalDenyBtn = document.getElementById('fit-detail-modal-deny-btn');

    // --- NEW: Variable to store current fit ID ---
    let currentModalFitId = null;


    function openFitModal(fitId) {
        if (!fitModalOverlay) return;

        // --- NEW: Store fitId and show footer buttons ---
        currentModalFitId = fitId;
        if(fitModalAcceptBtn) fitModalAcceptBtn.style.display = 'inline-block';
        if(fitModalDenyBtn) fitModalDenyBtn.style.display = 'inline-block';
        if(fitModalAcceptBtn) fitModalAcceptBtn.disabled = false;
        if(fitModalDenyBtn) fitModalDenyBtn.disabled = false;
        // --- END NEW ---

        // Show modal with spinner
        fitModalBody.innerHTML = '<div class="modal-spinner"></div>';
        fitModalTitle.textContent = "Loading Fit...";
        fitModalOverlay.classList.add('show');

        // Fetch fit details
        fetch(`{% url 'waitlist:api_get_fit_details' %}?fit_id=${fitId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to load fit details.');
                }
                return response.json();
            })
            .then(data => {
                // --- MODIFICATION: Handle new JSON structure ---
                // data = { full_fit_with_status: [], missing_items: [], doctrine_name: "..." }

                fitModalTitle.textContent = `Fit vs. ${data.doctrine_name}`;

                let html = '<div class="fit-modal-sub-container">';

                // --- BUILD THE NEW "SUBMITTED FIT" LIST ---
                html += '<div>';
                html += '<h3 class="fit-modal-sub-header">Submitted Fit</h3>';
                html += '<ul class="fit-detail-list">';

                // --- THIS IS THE FIX ---
                // Check if data is an error OR if the fit list is missing/empty
                if (data.status === 'error' || !data.full_fit_with_status || data.full_fit_with_status.length === 0) {
                    // If data.status is 'error', show the error message
                    if (data.status === 'error') {
                        html += `<li style="color: #ff8a8a; white-space: normal;">Error loading fit: ${data.message}</li>`;
                    } else {
                        // Otherwise, just show "Fit is empty"
                        html += '<li style="color: #999; font-style: italic;">Fit is empty.</li>';
                    }
                // --- END THE FIX ---
                } else {

                    let isEven = false; // <-- 1. Initialize even/odd tracker
                    let isFirstItem = true; // <-- NEW: Tracker for ship hull

                    data.full_fit_with_status.forEach(item => {
                        const itemKey = String(item.type_id || item.raw_line);
                        let itemClass = '';
                        let indentedListHtml = '';
                        let buttonsHtml = '';

                        // --- MODIFICATION: Also treat [Empty...] lines as spacers ---
                        if (item.name === "BLANK_LINE" || (item.name && item.name.startsWith('[Empty'))) {
                        // --- END MODIFICATION ---
                            html += `<li class="fit-item-blank-line"></li>`;
                            isEven = false; // <-- 2. Reset tracker on spacer
                            isFirstItem = false; // No longer first item
                            return; // 'continue' in a forEach
                        }

                        // --- MODIFIED: Use switch statement for new status ---
                        switch (item.status) {
                            case 'accepted_sub':
                                itemClass = 'fit-item-accepted-sub'; // Green
                                if (item.substitutes_for && item.substitutes_for.length > 0) {
                                    indentedListHtml = '<ul class="fit-item-sub-for-list">'; // Green dashed border
                                    item.substitutes_for.forEach(match => {
                                        indentedListHtml += `<li class="fit-item-sub-for-item">`;
                                        indentedListHtml += `<img src="${match.icon_url}" alt="${match.name}">`;
                                        indentedListHtml += `<span>Substitutes for: ${match.name} (x${match.quantity})</span>`;
                                        indentedListHtml += `</li>`;
                                    });
                                    indentedListHtml += '</ul>';
                                }
                                break;

                            case 'problem':
                                itemClass = 'fit-item-problem'; // Yellow
                                if (item.potential_matches && item.potential_matches.length > 0) {
                                    indentedListHtml = '<ul class="fit-item-missing-list">'; // Yellow dashed border
                                    item.potential_matches.forEach(match => {
                                        indentedListHtml += `<li class="fit-item-missing-item">`;
                                        indentedListHtml += `<img src="${match.icon_url}" alt="${match.name}">`;
                                        indentedListHtml += `<span>Missing: ${match.name} (x${match.quantity})</span>`;
                                        indentedListHtml += `</li>`;
                                    });
                                    indentedListHtml += '</ul>';

                                    // --- MODIFIED: Only show accept button ---
                                    const match = item.potential_matches[0]; // Assume 1:1
                                    // --- THIS IS THE FIX: Removed whitespace inside button ---
                                    buttonsHtml = `<div class="sub-action-buttons">
                                        <button class="fc-btn btn-approve js-sub-accept"
                                            data-problem-item-id="${item.type_id}"
                                            data-problem-item-name="${item.name}"
                                            data-missing-item-id="${match.type_id}"
                                            data-missing-item-name="${match.name}"
                                            title="Accept ${item.name} as substitute for ${match.name}">&#10003;</button>
                                    </div>`;
                                    // --- END THE FIX ---
                                } else {
                                    // Problem item with no potential matches
                                    indentedListHtml = `<span class="fit-item-problem-tag">(Wrong Item)</span>`;
                                }
                                break;

                            case 'doctrine':
                            default:
                                itemClass = ''; // Standard item
                                break;
                        }

                        // <-- 3. Apply 'even' class if needed
                        const evenClass = isEven ? 'fit-item-even' : '';
                        if (evenClass) {
                            itemClass += ` ${evenClass}`; // Add to existing classes
                        }

                        html += `<li class="${itemClass}" title="${item.name}" data-item-type-id="${itemKey}">`;

                        // Logic for icon
                        if (item.icon_url) {
                            html += `<img src="${item.icon_url}" alt="${item.name}" class="fit-modal-icon">`;
                        } else if (item.type_id) {
                             html += `<img src="https://images.evetech.net/types/${item.type_id}/icon?size=32" alt="${item.name}" class="fit-modal-icon" onerror="this.style.display='none'">`;
                        } else {
                            html += '<div class="fit-modal-icon-placeholder"></div>';
                        }

                        // Display the raw line
                        if (item.raw_line) {
                             const safe_line = item.raw_line.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                             html += `<span>${safe_line}</span>`;
                        } else {
                             html += `<span>${item.name}${item.quantity > 1 ? ' x' + item.quantity : ''}</span>`;
                        }

                        // Add buttons and indented list
                        html += buttonsHtml;
                        html += indentedListHtml;

                        html += '</li>';

                        // --- FIX: Don't toggle on the first (ship) line ---
                        if (isFirstItem) {
                            isFirstItem = false; // Ship line is done
                        } else {
                            isEven = !isEven; // <-- 4. Toggle for next item
                        }
                    });
                }
                html += '</ul></div>';

                html += '</div>'; // Close .fit-modal-sub-container

                fitModalBody.innerHTML = html;

                // --- MODIFIED: Add event listeners for the new buttons ---
                fitModalBody.querySelectorAll('.js-sub-accept').forEach(button => {
                    button.addEventListener('click', (event) => handleSubstitutionAction(event, 'accept'));
                });
                // --- END MODIFICATION ---

            })
            .catch(error => {
                fitModalBody.innerHTML = `<p style="color: #ff8a8a; padding: 20px;">Error: ${error.message}</p>`;
            });
    }

    function closeFitModal() {
        if (fitModalOverlay) {
            fitModalOverlay.classList.remove('show');

            // --- NEW: Reset modal state ---
            currentModalFitId = null;
            if(fitModalAcceptBtn) fitModalAcceptBtn.style.display = 'none';
            if(fitModalDenyBtn) fitModalDenyBtn.style.display = 'none';
            if(fitModalAcceptBtn) fitModalAcceptBtn.disabled = false;
            if(fitModalDenyBtn) fitModalDenyBtn.disabled = false;
            // --- END NEW ---
        }
    }

    // ---
    // --- CUSTOM CONFIRM MODAL (REMOVED)
    // --- The function 'showCustomConfirm' is now in base.html
    // ---


    // --- MODIFIED: Replaced showSubstitutionDropdown with handleSubstitutionAction ---
    function handleSubstitutionAction(event, action) {
        const button = event.target.closest('button');
        if (!button) return;

        // --- MODIFIED: Remove 'deny' logic ---
        if (action === 'accept') {
            const problemItemId = button.dataset.problemItemId;
            const missingItemId = button.dataset.missingItemId;
            const problemItemName = button.dataset.problemItemName;
            const missingItemName = button.dataset.missingItemName;

            const listItem = button.closest('li[data-item-type-id]');

            if (!missingItemId) {
                alert("Missing doctrine item ID not found for substitution.");
                return;
            }

            // Disable the button
            button.disabled = true;

            // --- MODIFIED: Use new custom confirm ---
            const confirmMessage = `Add "<b>${problemItemName}</b>" as a substitute for "<b>${missingItemName}</b>"?`;

            const performSubstitution = () => {
                // This is the code that runs on "Confirm"
                const formData = new FormData();
                formData.append('base_item_id', missingItemId);
                formData.append('substitute_item_id', problemItemId);

                fetch("{% url 'waitlist:api_add_substitution' %}", {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrfToken,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // --- MODIFIED: Change color, don't remove ---
                        listItem.classList.remove('fit-item-problem');
                        listItem.classList.add('fit-item-accepted-sub');

                        // Remove the button container
                        const buttonContainer = button.closest('.sub-action-buttons');
                        if (buttonContainer) {
                            buttonContainer.remove();
                        }

                        // Find and update the indented list
                        const missingList = listItem.querySelector('.fit-item-missing-list');
                        if (missingList) {
                            missingList.classList.remove('fit-item-missing-list');
                            missingList.classList.add('fit-item-sub-for-list'); // Change border color

                            // Re-build content as "Substitutes for..."
                            let subHtml = `<li class="fit-item-sub-for-item">`;
                            const missingImg = missingList.querySelector('img');
                            if (missingImg) {
                                subHtml += missingImg.outerHTML;
                            }
                            subHtml += `<span>Substitutes for: ${missingItemName}</span>`;
                            subHtml += `</li>`;
                            missingList.innerHTML = subHtml;
                        }

                        // Don't show an alert, the visual change is the feedback
                        // alert(data.message);
                    } else {
                        alert(`Error: ${data.message}`);
                        button.disabled = false;
                    }
                })
                .catch(error => {
                    alert(`Network Error: ${error.message}`);
                    button.disabled = false;
                });
            };

            // Show the custom confirm box
            showCustomConfirm(confirmMessage, performSubstitution);

            // Re-enable button if user cancels (the 'cancel' button on the
            // confirm modal will just hide the modal, so we must re-enable)
            // We'll add a one-time listener to the cancel button for this.
            const confirmCancelBtn = document.getElementById('custom-confirm-cancel-btn');
            const confirmOkBtn = document.getElementById('custom-confirm-ok-btn');

            const tempCancelListener = () => {
                button.disabled = false;
                confirmCancelBtn.removeEventListener('click', tempCancelListener);
                confirmOkBtn.removeEventListener('click', tempCancelListener); // Also clear if they click OK
            };
            confirmCancelBtn.addEventListener('click', tempCancelListener);
            confirmOkBtn.addEventListener('click', tempCancelListener); // Clean up listener
            // --- END MODIFICATION ---

        }
        // --- No 'deny' logic ---
    }
    // --- END MODIFICATION ---


    // Add close listeners for the modal
    if (fitModalOverlay) {
        fitModalCloseBtn.addEventListener('click', closeFitModal);
        fitModalCancelBtn.addEventListener('click', closeFitModal);
        fitModalOverlay.addEventListener('click', (e) => {
            if (e.target === fitModalOverlay) {
                closeFitModal();
            }
        });
    }


    // This function sets up all our event listeners
    function initializeWaitlist() {

        // --- NEW: Add listeners for modal footer buttons ---
        if (isFC) {
            if(fitModalAcceptBtn) fitModalAcceptBtn.addEventListener('click', () => {
                if (currentModalFitId) {
                    // Reuse the existing FC action handler
                    // We mock the 'event' object it expects
                    const mockEvent = {
                        target: {
                            closest: () => ({
                                dataset: {
                                    fitId: currentModalFitId,
                                    action: 'approve'
                                }
                            })
                        }
                    };
                    handleFCAction(mockEvent);
                    closeFitModal(); // Close modal after action
                }
            });

            if(fitModalDenyBtn) fitModalDenyBtn.addEventListener('click', () => {
                if (currentModalFitId) {
                    const mockEvent = {
                        target: {
                            closest: () => ({
                                dataset: {
                                    fitId: currentModalFitId,
                                    action: 'deny'
                                }
                            })
                        }
                    };
                    handleFCAction(mockEvent);
                    closeFitModal(); // Close modal after action
                }
            });
        }
        // --- END NEW ---

        // --- 4. MODIFIED: Add event delegation ---
        waitlistContainer.addEventListener('click', (event) => {
            // Check for FC action click
            const fcButton = event.target.closest('.fc-btn');
            if (isFC && fcButton) {
                // --- MODIFICATION: Route to correct handler ---
                if (fcButton.classList.contains('btn-invite')) {
                    handleFCInvite(event);
                } else {
                    handleFCAction(event);
                }
                // --- END MODIFICATION ---
                return; // Stop processing
            }

            // Check for Fit Modal click
            const fitModalButton = event.target.closest('.js-open-fit-modal');
            if (isFC && fitModalButton) {
                const fitId = fitModalButton.dataset.fitId;
                openFitModal(fitId);
                return; // Stop processing
            }
        });
        // --- END MODIFICATION ---

        // Run timers
        updateWaitTimers(); // Run once on load
        if (timerInterval) clearInterval(timerInterval); // Clear old timer
        timerInterval = setInterval(updateWaitTimers, 10000); // Update timers every 10s

        // Start live polling
        if (pollingInterval) clearInterval(pollingInterval); // Clear old poller
        pollingInterval = setInterval(fetchWaitlistHTML, 5000); // Poll every 5s
    }

    // --- 5. PAGE INITIALIZATION ---

    document.addEventListener('DOMContentLoaded', () => {
        // Enable the X-Up button (it's disabled by default in base.html)
        // We do this here so it's only enabled if the page loads correctly.
        const xupButton = document.getElementById('xup-modal-button');
        const openWaitlist = {{ open_waitlist.pk|default:"null" }};

        if (xupButton && openWaitlist !== null) {
            xupButton.disabled = false;
        }

        // Start all the interactive parts
        initializeWaitlist();
    });

</script>
{% endblock %}